<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>flatnest.flatnest API documentation</title>
<meta name="description" content="This module converts to/from a nested structure (e.g. list of lists of lists of ... of values) and a (nest pattern, flat list) tuple â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>flatnest.flatnest</code></h1>
</header>
<section id="section-intro">
<p>This module converts to/from a nested structure (e.g. list of lists of lists of &hellip; of values) and a (nest pattern, flat list) tuple</p>
<p>The nest pattern is a string consisting solely of square brackets and digits.
A number represents the number of consecutive values at the current level of the nested structure.
An opening square bracket represents entering a deeper level of nesting.
A closing square bracket represents leaving a deper level of nesting.
The square brackets at the top level (would be first and last characters of every pattern) are omitted.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module converts to/from a nested structure (e.g. list of lists of lists of ... of values) and a (nest pattern, flat list) tuple

The nest pattern is a string consisting solely of square brackets and digits.
A number represents the number of consecutive values at the current level of the nested structure.
An opening square bracket represents entering a deeper level of nesting.
A closing square bracket represents leaving a deper level of nesting.
The square brackets at the top level (would be first and last characters of every pattern) are omitted.
&#34;&#34;&#34;

import re
from collections import deque
from enum import Enum
class NestDirective(Enum):
    DFS_PUSH=1
    DFS_POP=2
    BFS_QUEUE=3
    BFS_SERVE=4
directive_token_map = {
        NestDirective.DFS_PUSH: &#39;[&#39;,
        NestDirective.DFS_POP: &#39;]&#39;,
        NestDirective.BFS_QUEUE: &#39;*&#39;,
        NestDirective.BFS_SERVE: &#39;|&#39;,
        }
#invert the directive_token_map dict
token_directive_map = {token:directive for directive,token in directive_token_map.items()}

def dfs(nested_structure,include_nest_directives=False):
    &#34;&#34;&#34;
    Implements a depth-first-search traversal of a nested list structure

    &gt;&gt;&gt; list(dfs([1,[2,3,[4,5,[6,7],8,9],10,11],12]))
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    &#34;&#34;&#34;
    stack = deque([[nested_structure,0]])
    while len(stack) &gt; 0:
        tree,pos = stack[-1]
        while pos &lt; len(tree):
            item = tree[pos]
            pos += 1
            if isinstance(item,(list,tuple)):
                if include_nest_directives:
                    yield NestDirective.DFS_PUSH
                stack[-1][1] = pos
                stack.append([item,0])
                break
            else:
                yield item
        if pos == len(tree):
            if len(stack) &gt; 1 and include_nest_directives:
                yield NestDirective.DFS_POP
            stack.pop()
def bfs(nested_structure,include_nest_directives=False):
    &#34;&#34;&#34;
    Implements a breadth-first-search traversal of a nested list structure
    
    &gt;&gt;&gt; list(bfs([1,[2,3,[4,5,[6,7],8,9],10,11],12]))
    [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7]
    &#34;&#34;&#34;
    queue = deque([nested_structure])
    while len(queue) &gt; 0:
        tree = queue.popleft()
        for item in tree:
            if isinstance(item,(list,tuple)):
                if include_nest_directives:
                    yield NestDirective.BFS_QUEUE
                queue.append(item)
            else:
                yield item
        if len(queue) &gt; 0 and include_nest_directives:
            yield NestDirective.BFS_SERVE


def flatten(nested_structure,algorithm=dfs):
    &#34;&#34;&#34;
    Traverses the nested structure according to the algorithm.
    Produces a structure pattern string and a flat list

    The structure pattern can be combined with the flat list to reconstruct the additional structure using the deflatten function
    The flat list corresponds to the order of traversal in the provided algorithm parameter

    
    &gt;&gt;&gt; flatten([1,[2,3,[4,5,[6,7],8,9],10,11],12])
    (&#39;1[2[2[2]2]2]1&#39;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

    &gt;&gt;&gt; flatten([1,[2,3,[4,5,[6,7],8,9],10,11],12],bfs)
    (&#39;1*1|2*2|2*2|2&#39;, [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7])

    &#34;&#34;&#34;
    if algorithm not in [dfs,bfs]:
        raise Exception(&#39;algorithm must be either the function dfs or the function bfs&#39;)
    pattern_list = []
    flat_list = []
    consecutive_item_count = 0
    for item in algorithm(nested_structure,include_nest_directives=True):
        if isinstance(item,NestDirective):
            if consecutive_item_count &gt; 0:
                pattern_list.append(str(consecutive_item_count))
            consecutive_item_count = 0
            pattern_list.append(directive_token_map[item])
        else:
            consecutive_item_count += 1
            flat_list.append(item)
    if consecutive_item_count &gt; 0:
        pattern_list.append(str(consecutive_item_count))
    structure_pattern = &#39;&#39;.join(pattern_list)
    return (structure_pattern,flat_list)

def parse_pattern(structure_pattern):
    &#34;&#34;&#34;
    Splits the structure pattern into integers and nest directive enum values
    &#34;&#34;&#34;
    return [(token_directive_map[token] if token in token_directive_map else int(token)) for token in re.split(&#39;([&#39;+re.escape(&#39;&#39;.join(directive_token_map.values()))+&#39;])&#39;,structure_pattern)]

def deflatten(structure_pattern,flat_list):
    &#34;&#34;&#34;
    Given a structure pattern and a flat list, construct a nested list structure

    &gt;&gt;&gt; deflatten(&#39;1[2[2[2]2]2]1&#39;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
    [1, [2, 3, [4, 5, [6, 7], 8, 9], 10, 11], 12]

    &gt;&gt;&gt; deflatten(&#39;1*1|2*2|2*2|2&#39;, [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7])
    [1, [2, 3, [4, 5, [6, 7], 8, 9], 10, 11], 12]

    &#34;&#34;&#34;

    structure_directives = parse_pattern(structure_pattern)

    stackqueue = deque()
    nested_structure = []
    top_nested_structure = nested_structure
    flat_position = 0
    alg = None
    for directive in structure_directives:
        if directive is NestDirective.DFS_PUSH:
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            stackqueue.append(nested_structure)
            nested_structure = []
            stackqueue[-1].append(nested_structure)
        elif directive is NestDirective.DFS_POP: 
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            nested_structure = stackqueue.pop()
        elif directive is NestDirective.BFS_QUEUE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            subtree = []
            stackqueue.append(subtree)
            nested_structure.append(subtree)
        elif directive is NestDirective.BFS_SERVE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            nested_structure = stackqueue.popleft()
        else:
            #is a number -&gt; consume that many items
            if flat_position + directive &lt;= len(flat_list):
                nested_structure.extend(flat_list[flat_position:flat_position+directive])
                flat_position += directive
            else:
                raise Exception(&#39;structure_pattern implies more values than flat_list contains&#39;)
    if flat_position &lt; len(flat_list):
        raise Exception(&#39;flat_list has more data than structure_pattern implies&#39;)
    if len(stackqueue) != 0:
        raise Exception(&#39;Structure pattern contains either imbalanced directive tokens&#39;)
    return top_nested_structure

def get_nest_indices(structure_pattern,flat_index):
    &#34;&#34;&#34;
    Given a structure pattern and an index into the flat list, return the corresponding sequence of indices identifying the position in the nested structure.

    A negative flat index works from the end of the flat list

    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,0)
    [0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,1)
    [1, 0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,2)
    [1, 1]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,3)
    [1, 2, 0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,4)
    [1, 2, 1]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,5)
    [1, 2, 2, 0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,6)
    [1, 2, 2, 1]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,10)
    [1, 4]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,11)
    [2]

    &#34;&#34;&#34;
    nest_indices = [0]
    current_flat_index = 0
    nest_queue = []
    structure_directives = parse_pattern(structure_pattern)
    alg = None
    if flat_index &lt; 0:
        flat_index += sum(item for item in structure_directives if isinstance(item,int))
    for directive in structure_directives:
        if directive is NestDirective.DFS_PUSH:
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            nest_indices.append(0)
        elif directive is NestDirective.DFS_POP: 
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            nest_indices.pop()
            nest_indices[-1] += 1
        elif directive is NestDirective.BFS_QUEUE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            nest_queue.append(nest_indices[:])
            nest_indices[-1] += 1
            

        elif directive is NestDirective.BFS_SERVE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            nest_indices = nest_queue.popleft()
            nest_indices.append(0)
        else:
            #is a number 
            if current_flat_index &lt;= flat_index &lt; (current_flat_index + directive):
                nest_indices[-1] += (flat_index-current_flat_index)
                return nest_indices
            else:
                current_flat_index += directive
                nest_indices[-1] += directive
    raise Exception(&#39;flat index exceeds size implied by structure pattern&#39;)




def get_flat_index(structure_pattern,nest_indices):
    &#34;&#34;&#34;
    Given a structure pattern and a sequence of indices into the nested structure, return the corresponding flat list index

    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[0])
    0
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,0])
    1
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,1])
    2
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,0])
    3
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,1])
    4
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,2,0])
    5
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,2,1])
    6
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,4])
    10
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[2])
    11

    &#34;&#34;&#34;
    current_nest_indices = [0]
    flat_index = 0
    nest_queue = []
    structure_directives = parse_pattern(structure_pattern)
    alg = None
    for directive in structure_directives:
        if directive is NestDirective.DFS_PUSH:
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            current_nest_indices.append(0)
        elif directive is NestDirective.DFS_POP: 
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            current_nest_indices.pop()
            current_nest_indices[-1] += 1
        elif directive is NestDirective.BFS_QUEUE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            nest_queue.append(current_nest_indices[:])
            current_nest_indices[-1] += 1

        elif directive is NestDirective.BFS_SERVE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            current_nest_indices = nest_queue.popleft()
            current_nest_indices.append(0)
        else:
            #is a number 
            if current_nest_indices[:-1] == nest_indices[:-1] and (current_nest_indices[-1] &lt;= nest_indices[-1] &lt; (current_nest_indices[-1]+directive)):
                return flat_index + (nest_indices[-1] - current_nest_indices[-1])
            else:
                current_nest_indices[-1] += directive
                flat_index += directive
    raise Exception(&#39;The provided nest indices do not exist in the structure pattern&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="flatnest.flatnest.bfs"><code class="name flex">
<span>def <span class="ident">bfs</span></span>(<span>nested_structure, include_nest_directives=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements a breadth-first-search traversal of a nested list structure</p>
<pre><code class="python">&gt;&gt;&gt; list(bfs([1,[2,3,[4,5,[6,7],8,9],10,11],12]))
[1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bfs(nested_structure,include_nest_directives=False):
    &#34;&#34;&#34;
    Implements a breadth-first-search traversal of a nested list structure
    
    &gt;&gt;&gt; list(bfs([1,[2,3,[4,5,[6,7],8,9],10,11],12]))
    [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7]
    &#34;&#34;&#34;
    queue = deque([nested_structure])
    while len(queue) &gt; 0:
        tree = queue.popleft()
        for item in tree:
            if isinstance(item,(list,tuple)):
                if include_nest_directives:
                    yield NestDirective.BFS_QUEUE
                queue.append(item)
            else:
                yield item
        if len(queue) &gt; 0 and include_nest_directives:
            yield NestDirective.BFS_SERVE</code></pre>
</details>
</dd>
<dt id="flatnest.flatnest.deflatten"><code class="name flex">
<span>def <span class="ident">deflatten</span></span>(<span>structure_pattern, flat_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a structure pattern and a flat list, construct a nested list structure</p>
<pre><code class="python">&gt;&gt;&gt; deflatten('1[2[2[2]2]2]1', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
[1, [2, 3, [4, 5, [6, 7], 8, 9], 10, 11], 12]
</code></pre>
<pre><code class="python">&gt;&gt;&gt; deflatten('1*1|2*2|2*2|2', [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7])
[1, [2, 3, [4, 5, [6, 7], 8, 9], 10, 11], 12]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deflatten(structure_pattern,flat_list):
    &#34;&#34;&#34;
    Given a structure pattern and a flat list, construct a nested list structure

    &gt;&gt;&gt; deflatten(&#39;1[2[2[2]2]2]1&#39;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
    [1, [2, 3, [4, 5, [6, 7], 8, 9], 10, 11], 12]

    &gt;&gt;&gt; deflatten(&#39;1*1|2*2|2*2|2&#39;, [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7])
    [1, [2, 3, [4, 5, [6, 7], 8, 9], 10, 11], 12]

    &#34;&#34;&#34;

    structure_directives = parse_pattern(structure_pattern)

    stackqueue = deque()
    nested_structure = []
    top_nested_structure = nested_structure
    flat_position = 0
    alg = None
    for directive in structure_directives:
        if directive is NestDirective.DFS_PUSH:
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            stackqueue.append(nested_structure)
            nested_structure = []
            stackqueue[-1].append(nested_structure)
        elif directive is NestDirective.DFS_POP: 
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            nested_structure = stackqueue.pop()
        elif directive is NestDirective.BFS_QUEUE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            subtree = []
            stackqueue.append(subtree)
            nested_structure.append(subtree)
        elif directive is NestDirective.BFS_SERVE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            nested_structure = stackqueue.popleft()
        else:
            #is a number -&gt; consume that many items
            if flat_position + directive &lt;= len(flat_list):
                nested_structure.extend(flat_list[flat_position:flat_position+directive])
                flat_position += directive
            else:
                raise Exception(&#39;structure_pattern implies more values than flat_list contains&#39;)
    if flat_position &lt; len(flat_list):
        raise Exception(&#39;flat_list has more data than structure_pattern implies&#39;)
    if len(stackqueue) != 0:
        raise Exception(&#39;Structure pattern contains either imbalanced directive tokens&#39;)
    return top_nested_structure</code></pre>
</details>
</dd>
<dt id="flatnest.flatnest.dfs"><code class="name flex">
<span>def <span class="ident">dfs</span></span>(<span>nested_structure, include_nest_directives=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements a depth-first-search traversal of a nested list structure</p>
<pre><code class="python">&gt;&gt;&gt; list(dfs([1,[2,3,[4,5,[6,7],8,9],10,11],12]))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dfs(nested_structure,include_nest_directives=False):
    &#34;&#34;&#34;
    Implements a depth-first-search traversal of a nested list structure

    &gt;&gt;&gt; list(dfs([1,[2,3,[4,5,[6,7],8,9],10,11],12]))
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    &#34;&#34;&#34;
    stack = deque([[nested_structure,0]])
    while len(stack) &gt; 0:
        tree,pos = stack[-1]
        while pos &lt; len(tree):
            item = tree[pos]
            pos += 1
            if isinstance(item,(list,tuple)):
                if include_nest_directives:
                    yield NestDirective.DFS_PUSH
                stack[-1][1] = pos
                stack.append([item,0])
                break
            else:
                yield item
        if pos == len(tree):
            if len(stack) &gt; 1 and include_nest_directives:
                yield NestDirective.DFS_POP
            stack.pop()</code></pre>
</details>
</dd>
<dt id="flatnest.flatnest.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>nested_structure, algorithm=&lt;function dfs&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Traverses the nested structure according to the algorithm.
Produces a structure pattern string and a flat list</p>
<p>The structure pattern can be combined with the flat list to reconstruct the additional structure using the deflatten function
The flat list corresponds to the order of traversal in the provided algorithm parameter</p>
<pre><code class="python">&gt;&gt;&gt; flatten([1,[2,3,[4,5,[6,7],8,9],10,11],12])
('1[2[2[2]2]2]1', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
</code></pre>
<pre><code class="python">&gt;&gt;&gt; flatten([1,[2,3,[4,5,[6,7],8,9],10,11],12],bfs)
('1*1|2*2|2*2|2', [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(nested_structure,algorithm=dfs):
    &#34;&#34;&#34;
    Traverses the nested structure according to the algorithm.
    Produces a structure pattern string and a flat list

    The structure pattern can be combined with the flat list to reconstruct the additional structure using the deflatten function
    The flat list corresponds to the order of traversal in the provided algorithm parameter

    
    &gt;&gt;&gt; flatten([1,[2,3,[4,5,[6,7],8,9],10,11],12])
    (&#39;1[2[2[2]2]2]1&#39;, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

    &gt;&gt;&gt; flatten([1,[2,3,[4,5,[6,7],8,9],10,11],12],bfs)
    (&#39;1*1|2*2|2*2|2&#39;, [1, 12, 2, 3, 10, 11, 4, 5, 8, 9, 6, 7])

    &#34;&#34;&#34;
    if algorithm not in [dfs,bfs]:
        raise Exception(&#39;algorithm must be either the function dfs or the function bfs&#39;)
    pattern_list = []
    flat_list = []
    consecutive_item_count = 0
    for item in algorithm(nested_structure,include_nest_directives=True):
        if isinstance(item,NestDirective):
            if consecutive_item_count &gt; 0:
                pattern_list.append(str(consecutive_item_count))
            consecutive_item_count = 0
            pattern_list.append(directive_token_map[item])
        else:
            consecutive_item_count += 1
            flat_list.append(item)
    if consecutive_item_count &gt; 0:
        pattern_list.append(str(consecutive_item_count))
    structure_pattern = &#39;&#39;.join(pattern_list)
    return (structure_pattern,flat_list)</code></pre>
</details>
</dd>
<dt id="flatnest.flatnest.get_flat_index"><code class="name flex">
<span>def <span class="ident">get_flat_index</span></span>(<span>structure_pattern, nest_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a structure pattern and a sequence of indices into the nested structure, return the corresponding flat list index</p>
<pre><code class="python">&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[0])
0
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,0])
1
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,1])
2
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,2,0])
3
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,2,1])
4
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,2,2,0])
5
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,2,2,1])
6
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[1,4])
10
&gt;&gt;&gt; get_flat_index('1[2[2[2]2]2]1',[2])
11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_flat_index(structure_pattern,nest_indices):
    &#34;&#34;&#34;
    Given a structure pattern and a sequence of indices into the nested structure, return the corresponding flat list index

    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[0])
    0
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,0])
    1
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,1])
    2
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,0])
    3
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,1])
    4
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,2,0])
    5
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,2,2,1])
    6
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[1,4])
    10
    &gt;&gt;&gt; get_flat_index(&#39;1[2[2[2]2]2]1&#39;,[2])
    11

    &#34;&#34;&#34;
    current_nest_indices = [0]
    flat_index = 0
    nest_queue = []
    structure_directives = parse_pattern(structure_pattern)
    alg = None
    for directive in structure_directives:
        if directive is NestDirective.DFS_PUSH:
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            current_nest_indices.append(0)
        elif directive is NestDirective.DFS_POP: 
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            current_nest_indices.pop()
            current_nest_indices[-1] += 1
        elif directive is NestDirective.BFS_QUEUE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            nest_queue.append(current_nest_indices[:])
            current_nest_indices[-1] += 1

        elif directive is NestDirective.BFS_SERVE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            current_nest_indices = nest_queue.popleft()
            current_nest_indices.append(0)
        else:
            #is a number 
            if current_nest_indices[:-1] == nest_indices[:-1] and (current_nest_indices[-1] &lt;= nest_indices[-1] &lt; (current_nest_indices[-1]+directive)):
                return flat_index + (nest_indices[-1] - current_nest_indices[-1])
            else:
                current_nest_indices[-1] += directive
                flat_index += directive
    raise Exception(&#39;The provided nest indices do not exist in the structure pattern&#39;)</code></pre>
</details>
</dd>
<dt id="flatnest.flatnest.get_nest_indices"><code class="name flex">
<span>def <span class="ident">get_nest_indices</span></span>(<span>structure_pattern, flat_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a structure pattern and an index into the flat list, return the corresponding sequence of indices identifying the position in the nested structure.</p>
<p>A negative flat index works from the end of the flat list</p>
<pre><code class="python">&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',0)
[0]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',1)
[1, 0]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',2)
[1, 1]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',3)
[1, 2, 0]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',4)
[1, 2, 1]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',5)
[1, 2, 2, 0]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',6)
[1, 2, 2, 1]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',10)
[1, 4]
&gt;&gt;&gt; get_nest_indices('1[2[2[2]2]2]1',11)
[2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nest_indices(structure_pattern,flat_index):
    &#34;&#34;&#34;
    Given a structure pattern and an index into the flat list, return the corresponding sequence of indices identifying the position in the nested structure.

    A negative flat index works from the end of the flat list

    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,0)
    [0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,1)
    [1, 0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,2)
    [1, 1]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,3)
    [1, 2, 0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,4)
    [1, 2, 1]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,5)
    [1, 2, 2, 0]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,6)
    [1, 2, 2, 1]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,10)
    [1, 4]
    &gt;&gt;&gt; get_nest_indices(&#39;1[2[2[2]2]2]1&#39;,11)
    [2]

    &#34;&#34;&#34;
    nest_indices = [0]
    current_flat_index = 0
    nest_queue = []
    structure_directives = parse_pattern(structure_pattern)
    alg = None
    if flat_index &lt; 0:
        flat_index += sum(item for item in structure_directives if isinstance(item,int))
    for directive in structure_directives:
        if directive is NestDirective.DFS_PUSH:
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            nest_indices.append(0)
        elif directive is NestDirective.DFS_POP: 
            if alg is bfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = dfs
            nest_indices.pop()
            nest_indices[-1] += 1
        elif directive is NestDirective.BFS_QUEUE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            alg = bfs
            nest_queue.append(nest_indices[:])
            nest_indices[-1] += 1
            

        elif directive is NestDirective.BFS_SERVE: 
            if alg is dfs:
                raise Exception(&#39;Structure pattern contains both dfs and bfs tokens&#39;)
            nest_indices = nest_queue.popleft()
            nest_indices.append(0)
        else:
            #is a number 
            if current_flat_index &lt;= flat_index &lt; (current_flat_index + directive):
                nest_indices[-1] += (flat_index-current_flat_index)
                return nest_indices
            else:
                current_flat_index += directive
                nest_indices[-1] += directive
    raise Exception(&#39;flat index exceeds size implied by structure pattern&#39;)</code></pre>
</details>
</dd>
<dt id="flatnest.flatnest.parse_pattern"><code class="name flex">
<span>def <span class="ident">parse_pattern</span></span>(<span>structure_pattern)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits the structure pattern into integers and nest directive enum values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_pattern(structure_pattern):
    &#34;&#34;&#34;
    Splits the structure pattern into integers and nest directive enum values
    &#34;&#34;&#34;
    return [(token_directive_map[token] if token in token_directive_map else int(token)) for token in re.split(&#39;([&#39;+re.escape(&#39;&#39;.join(directive_token_map.values()))+&#39;])&#39;,structure_pattern)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flatnest.flatnest.NestDirective"><code class="flex name class">
<span>class <span class="ident">NestDirective</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NestDirective(Enum):
    DFS_PUSH=1
    DFS_POP=2
    BFS_QUEUE=3
    BFS_SERVE=4</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="flatnest.flatnest.NestDirective.BFS_QUEUE"><code class="name">var <span class="ident">BFS_QUEUE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="flatnest.flatnest.NestDirective.BFS_SERVE"><code class="name">var <span class="ident">BFS_SERVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="flatnest.flatnest.NestDirective.DFS_POP"><code class="name">var <span class="ident">DFS_POP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="flatnest.flatnest.NestDirective.DFS_PUSH"><code class="name">var <span class="ident">DFS_PUSH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="flatnest" href="index.html">flatnest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="flatnest.flatnest.bfs" href="#flatnest.flatnest.bfs">bfs</a></code></li>
<li><code><a title="flatnest.flatnest.deflatten" href="#flatnest.flatnest.deflatten">deflatten</a></code></li>
<li><code><a title="flatnest.flatnest.dfs" href="#flatnest.flatnest.dfs">dfs</a></code></li>
<li><code><a title="flatnest.flatnest.flatten" href="#flatnest.flatnest.flatten">flatten</a></code></li>
<li><code><a title="flatnest.flatnest.get_flat_index" href="#flatnest.flatnest.get_flat_index">get_flat_index</a></code></li>
<li><code><a title="flatnest.flatnest.get_nest_indices" href="#flatnest.flatnest.get_nest_indices">get_nest_indices</a></code></li>
<li><code><a title="flatnest.flatnest.parse_pattern" href="#flatnest.flatnest.parse_pattern">parse_pattern</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flatnest.flatnest.NestDirective" href="#flatnest.flatnest.NestDirective">NestDirective</a></code></h4>
<ul class="">
<li><code><a title="flatnest.flatnest.NestDirective.BFS_QUEUE" href="#flatnest.flatnest.NestDirective.BFS_QUEUE">BFS_QUEUE</a></code></li>
<li><code><a title="flatnest.flatnest.NestDirective.BFS_SERVE" href="#flatnest.flatnest.NestDirective.BFS_SERVE">BFS_SERVE</a></code></li>
<li><code><a title="flatnest.flatnest.NestDirective.DFS_POP" href="#flatnest.flatnest.NestDirective.DFS_POP">DFS_POP</a></code></li>
<li><code><a title="flatnest.flatnest.NestDirective.DFS_PUSH" href="#flatnest.flatnest.NestDirective.DFS_PUSH">DFS_PUSH</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>